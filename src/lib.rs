#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen 0.71.1 */

pub const OPUS_OK: u32 = 0;
pub const OPUS_BAD_ARG: i32 = -1;
pub const OPUS_BUFFER_TOO_SMALL: i32 = -2;
pub const OPUS_INTERNAL_ERROR: i32 = -3;
pub const OPUS_INVALID_PACKET: i32 = -4;
pub const OPUS_UNIMPLEMENTED: i32 = -5;
pub const OPUS_INVALID_STATE: i32 = -6;
pub const OPUS_ALLOC_FAIL: i32 = -7;
pub const OPUS_SET_APPLICATION_REQUEST: u32 = 4000;
pub const OPUS_GET_APPLICATION_REQUEST: u32 = 4001;
pub const OPUS_SET_BITRATE_REQUEST: u32 = 4002;
pub const OPUS_GET_BITRATE_REQUEST: u32 = 4003;
pub const OPUS_SET_MAX_BANDWIDTH_REQUEST: u32 = 4004;
pub const OPUS_GET_MAX_BANDWIDTH_REQUEST: u32 = 4005;
pub const OPUS_SET_VBR_REQUEST: u32 = 4006;
pub const OPUS_GET_VBR_REQUEST: u32 = 4007;
pub const OPUS_SET_BANDWIDTH_REQUEST: u32 = 4008;
pub const OPUS_GET_BANDWIDTH_REQUEST: u32 = 4009;
pub const OPUS_SET_COMPLEXITY_REQUEST: u32 = 4010;
pub const OPUS_GET_COMPLEXITY_REQUEST: u32 = 4011;
pub const OPUS_SET_INBAND_FEC_REQUEST: u32 = 4012;
pub const OPUS_GET_INBAND_FEC_REQUEST: u32 = 4013;
pub const OPUS_SET_PACKET_LOSS_PERC_REQUEST: u32 = 4014;
pub const OPUS_GET_PACKET_LOSS_PERC_REQUEST: u32 = 4015;
pub const OPUS_SET_DTX_REQUEST: u32 = 4016;
pub const OPUS_GET_DTX_REQUEST: u32 = 4017;
pub const OPUS_SET_VBR_CONSTRAINT_REQUEST: u32 = 4020;
pub const OPUS_GET_VBR_CONSTRAINT_REQUEST: u32 = 4021;
pub const OPUS_SET_FORCE_CHANNELS_REQUEST: u32 = 4022;
pub const OPUS_GET_FORCE_CHANNELS_REQUEST: u32 = 4023;
pub const OPUS_SET_SIGNAL_REQUEST: u32 = 4024;
pub const OPUS_GET_SIGNAL_REQUEST: u32 = 4025;
pub const OPUS_GET_LOOKAHEAD_REQUEST: u32 = 4027;
pub const OPUS_GET_SAMPLE_RATE_REQUEST: u32 = 4029;
pub const OPUS_GET_FINAL_RANGE_REQUEST: u32 = 4031;
pub const OPUS_GET_PITCH_REQUEST: u32 = 4033;
pub const OPUS_SET_GAIN_REQUEST: u32 = 4034;
pub const OPUS_GET_GAIN_REQUEST: u32 = 4045;
pub const OPUS_SET_LSB_DEPTH_REQUEST: u32 = 4036;
pub const OPUS_GET_LSB_DEPTH_REQUEST: u32 = 4037;
pub const OPUS_GET_LAST_PACKET_DURATION_REQUEST: u32 = 4039;
pub const OPUS_SET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4040;
pub const OPUS_GET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4041;
pub const OPUS_SET_PREDICTION_DISABLED_REQUEST: u32 = 4042;
pub const OPUS_GET_PREDICTION_DISABLED_REQUEST: u32 = 4043;
pub const OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4046;
pub const OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4047;
pub const OPUS_GET_IN_DTX_REQUEST: u32 = 4049;
pub const OPUS_SET_DRED_DURATION_REQUEST: u32 = 4050;
pub const OPUS_GET_DRED_DURATION_REQUEST: u32 = 4051;
pub const OPUS_SET_DNN_BLOB_REQUEST: u32 = 4052;
pub const OPUS_AUTO: i32 = -1000;
pub const OPUS_BITRATE_MAX: i32 = -1;
pub const OPUS_APPLICATION_VOIP: u32 = 2048;
pub const OPUS_APPLICATION_AUDIO: u32 = 2049;
pub const OPUS_APPLICATION_RESTRICTED_LOWDELAY: u32 = 2051;
pub const OPUS_SIGNAL_VOICE: u32 = 3001;
pub const OPUS_SIGNAL_MUSIC: u32 = 3002;
pub const OPUS_BANDWIDTH_NARROWBAND: u32 = 1101;
pub const OPUS_BANDWIDTH_MEDIUMBAND: u32 = 1102;
pub const OPUS_BANDWIDTH_WIDEBAND: u32 = 1103;
pub const OPUS_BANDWIDTH_SUPERWIDEBAND: u32 = 1104;
pub const OPUS_BANDWIDTH_FULLBAND: u32 = 1105;
pub const OPUS_FRAMESIZE_ARG: u32 = 5000;
pub const OPUS_FRAMESIZE_2_5_MS: u32 = 5001;
pub const OPUS_FRAMESIZE_5_MS: u32 = 5002;
pub const OPUS_FRAMESIZE_10_MS: u32 = 5003;
pub const OPUS_FRAMESIZE_20_MS: u32 = 5004;
pub const OPUS_FRAMESIZE_40_MS: u32 = 5005;
pub const OPUS_FRAMESIZE_60_MS: u32 = 5006;
pub const OPUS_FRAMESIZE_80_MS: u32 = 5007;
pub const OPUS_FRAMESIZE_100_MS: u32 = 5008;
pub const OPUS_FRAMESIZE_120_MS: u32 = 5009;
pub const OPUS_RESET_STATE: u32 = 4028;
pub type opus_int8 = i8;
pub type opus_uint8 = u8;
pub type opus_int16 = i16;
pub type opus_uint16 = u16;
pub type opus_int32 = i32;
pub type opus_uint32 = u32;
pub type opus_int64 = i64;
pub type opus_uint64 = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusEncoder {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDecoder {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDREDDecoder {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDRED {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusRepacketizer {
  _unused: [u8; 0],
}
unsafe extern "C" {
  #[doc = "Converts an opus error code into a human readable string.\n\n# Arguments\n\n* `error` [in]  - <tt>int</tt>: Error number\n\n# Returns\n\nError string"]
  pub fn opus_strerror(error: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
  #[doc = "Gets the libopus version string.\nApplications may look for the substring \"-fixed\" in the version string to\ndetermine whether they have a fixed-point or floating-point build at\nruntime.\n\n# Returns\n\nVersion string"]
  pub fn opus_get_version_string() -> *const ::core::ffi::c_char;
  #[doc = "Gets the size of an <code>OpusEncoder</code> structure.\n\n# Arguments\n\n* `channels` [in]  - <tt>int</tt>: Number of channels.\nThis must be 1 or 2.\n\n# Returns\n\nThe size in bytes."]
  pub fn opus_encoder_get_size(channels: ::core::ffi::c_int) -> ::core::ffi::c_int;
  #[doc = "Allocates and initializes an encoder state.\nThere are three coding modes:\n[`OPUS_APPLICATION_VOIP`] gives best quality at a given bitrate for voice\nsignals. It enhances the  input signal by high-pass filtering and\nemphasizing formants and harmonics. Optionally  it includes in-band\nforward error correction to protect against packet loss. Use this\nmode for typical VoIP applications. Because of the enhancement,\neven at high bitrates the output may sound different from the input.\n[`OPUS_APPLICATION_AUDIO`] gives best quality at a given bitrate for most\nnon-voice signals like music. Use this mode for music and mixed\n(music/voice) content, broadcast, and applications requiring less\nthan 15 ms of coding delay.\n[`OPUS_APPLICATION_RESTRICTED_LOWDELAY`] configures low-delay mode that\ndisables the speech-optimized mode in exchange for slightly reduced delay.\nThis mode can only be set on an newly initialized or freshly reset encoder\nbecause it changes the codec delay.\nThis is useful when the caller knows that the speech-optimized modes will not be needed (use with caution).\n\n# Arguments\n\n* `Fs` [in]  - <tt>opus_int32</tt>: Sampling rate of input signal (Hz)\nThis must be one of 8000, 12000, 16000,\n24000, or 48000.\n* `channels` [in]  - <tt>int</tt>: Number of channels (1 or 2) in input signal\n* `application` [in]  - <tt>int</tt>: Coding mode (one of [`OPUS_APPLICATION_VOIP,`] [`OPUS_APPLICATION_AUDIO,`] or [`OPUS_APPLICATION_RESTRICTED_LOWDELAY)`]\n* `error` [out]  - <tt>int*</tt>: [`opus_errorcodes`]\n> **Note** Regardless of the sampling rate and number channels selected, the Opus encoder\ncan switch to a lower audio bandwidth or number of channels if the bitrate\nselected is too low. This also means that it is safe to always use 48 kHz stereo input\nand let the encoder optimize the encoding."]
  pub fn opus_encoder_create(
    Fs: opus_int32,
    channels: ::core::ffi::c_int,
    application: ::core::ffi::c_int,
    error: *mut ::core::ffi::c_int,
  ) -> *mut OpusEncoder;
  #[doc = "Initializes a previously allocated encoder state\nThe memory pointed to by st must be at least the size returned by opus_encoder_get_size().\nThis is intended for applications which use their own allocator instead of malloc.\n\n# See also\n\n> [`opus_encoder_create(),opus_encoder_get_size()`]\nTo reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusEncoder*</tt>: Encoder state\n* `Fs` [in]  - <tt>opus_int32</tt>: Sampling rate of input signal (Hz)\nThis must be one of 8000, 12000, 16000,\n24000, or 48000.\n* `channels` [in]  - <tt>int</tt>: Number of channels (1 or 2) in input signal\n* `application` [in]  - <tt>int</tt>: Coding mode (one of OPUS_APPLICATION_VOIP, OPUS_APPLICATION_AUDIO, or OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n@retval #OPUS_OK Success or [`opus_errorcodes`]"]
  pub fn opus_encoder_init(
    st: *mut OpusEncoder,
    Fs: opus_int32,
    channels: ::core::ffi::c_int,
    application: ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Encodes an Opus frame.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusEncoder*</tt>: Encoder state\n* `pcm` [in]  - <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)\n* `frame_size` [in]  - <tt>int</tt>: Number of samples per channel in the\ninput signal.\nThis must be an Opus frame size for\nthe encoder's sampling rate.\nFor example, at 48 kHz the permitted\nvalues are 120, 240, 480, 960, 1920,\nand 2880.\nPassing in a duration of less than\n10 ms (480 samples at 48 kHz) will\nprevent the encoder from using the LPC\nor hybrid modes.\n* `data` [out]  - <tt>unsigned char*</tt>: Output payload.\nThis must contain storage for at\nleast _max_data_bytes._\n* `max_data_bytes` [in]  - <tt>opus_int32</tt>: Size of the allocated\nmemory for the output\npayload. This may be\nused to impose an upper limit on\nthe instant bitrate, but should\nnot be used as the only bitrate\ncontrol. Use #OPUS_SET_BITRATE to\ncontrol the bitrate.\n\n# Returns\n\nThe length of the encoded packet (in bytes) on success or a\nnegative error code (see [`opus_errorcodes)`] on failure."]
  pub fn opus_encode(
    st: *mut OpusEncoder,
    pcm: *const opus_int16,
    frame_size: ::core::ffi::c_int,
    data: *mut ::core::ffi::c_uchar,
    max_data_bytes: opus_int32,
  ) -> opus_int32;
  #[doc = "Encodes an Opus frame.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusEncoder*</tt>: Encoder state\n* `pcm` [in]  - <tt>opus_int32*</tt>: Input signal (interleaved if 2 channels) representing (or slightly exceeding) 24-bit values. length is frame_size*channels*sizeof(opus_int32)\n* `frame_size` [in]  - <tt>int</tt>: Number of samples per channel in the\ninput signal.\nThis must be an Opus frame size for\nthe encoder's sampling rate.\nFor example, at 48 kHz the permitted\nvalues are 120, 240, 480, 960, 1920,\nand 2880.\nPassing in a duration of less than\n10 ms (480 samples at 48 kHz) will\nprevent the encoder from using the LPC\nor hybrid modes.\n* `data` [out]  - <tt>unsigned char*</tt>: Output payload.\nThis must contain storage for at\nleast _max_data_bytes._\n* `max_data_bytes` [in]  - <tt>opus_int32</tt>: Size of the allocated\nmemory for the output\npayload. This may be\nused to impose an upper limit on\nthe instant bitrate, but should\nnot be used as the only bitrate\ncontrol. Use #OPUS_SET_BITRATE to\ncontrol the bitrate.\n\n# Returns\n\nThe length of the encoded packet (in bytes) on success or a\nnegative error code (see [`opus_errorcodes)`] on failure."]
  pub fn opus_encode24(
    st: *mut OpusEncoder,
    pcm: *const opus_int32,
    frame_size: ::core::ffi::c_int,
    data: *mut ::core::ffi::c_uchar,
    max_data_bytes: opus_int32,
  ) -> opus_int32;
  #[doc = "Encodes an Opus frame from floating point input.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusEncoder*</tt>: Encoder state\n* `pcm` [in]  - <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0.\nSamples with a range beyond +/-1.0 are supported but will\nbe clipped by decoders using the integer API and should\nonly be used if it is known that the far end supports\nextended dynamic range.\nlength is frame_size*channels*sizeof(float)\n* `frame_size` [in]  - <tt>int</tt>: Number of samples per channel in the\ninput signal.\nThis must be an Opus frame size for\nthe encoder's sampling rate.\nFor example, at 48 kHz the permitted\nvalues are 120, 240, 480, 960, 1920,\nand 2880.\nPassing in a duration of less than\n10 ms (480 samples at 48 kHz) will\nprevent the encoder from using the LPC\nor hybrid modes.\n* `data` [out]  - <tt>unsigned char*</tt>: Output payload.\nThis must contain storage for at\nleast _max_data_bytes._\n* `max_data_bytes` [in]  - <tt>opus_int32</tt>: Size of the allocated\nmemory for the output\npayload. This may be\nused to impose an upper limit on\nthe instant bitrate, but should\nnot be used as the only bitrate\ncontrol. Use #OPUS_SET_BITRATE to\ncontrol the bitrate.\n\n# Returns\n\nThe length of the encoded packet (in bytes) on success or a\nnegative error code (see [`opus_errorcodes)`] on failure."]
  pub fn opus_encode_float(
    st: *mut OpusEncoder,
    pcm: *const f32,
    frame_size: ::core::ffi::c_int,
    data: *mut ::core::ffi::c_uchar,
    max_data_bytes: opus_int32,
  ) -> opus_int32;
  #[doc = "Frees an <code>OpusEncoder</code> allocated by opus_encoder_create().\n\n# Arguments\n\n* `st` [in]  - <tt>OpusEncoder*</tt>: State to be freed."]
  pub fn opus_encoder_destroy(st: *mut OpusEncoder);
  #[doc = "Perform a CTL function on an Opus encoder.\nGenerally the request and subsequent arguments are generated\nby a convenience macro.\n\n# Arguments\n\n* `st` - <tt>OpusEncoder*</tt>: Encoder state.\n* `request` - This and all remaining parameters should be replaced by one\nof the convenience macros in [`opus_genericctls`] or\n[`opus_encoderctls.`]\n\n# See also\n\n> [`opus_genericctls`]\n> [`opus_encoderctls`]"]
  pub fn opus_encoder_ctl(st: *mut OpusEncoder, request: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
  #[doc = "Gets the size of an <code>OpusDecoder</code> structure.\n\n# Arguments\n\n* `channels` [in]  - <tt>int</tt>: Number of channels.\nThis must be 1 or 2.\n\n# Returns\n\nThe size in bytes."]
  pub fn opus_decoder_get_size(channels: ::core::ffi::c_int) -> ::core::ffi::c_int;
  #[doc = "Allocates and initializes a decoder state.\n\n# Arguments\n\n* `Fs` [in]  - <tt>opus_int32</tt>: Sample rate to decode at (Hz).\nThis must be one of 8000, 12000, 16000,\n24000, or 48000.\n* `channels` [in]  - <tt>int</tt>: Number of channels (1 or 2) to decode\n* `error` [out]  - <tt>int*</tt>: #OPUS_OK Success or [`opus_errorcodes`]\nInternally Opus stores data at 48000 Hz, so that should be the default\nvalue for Fs. However, the decoder can efficiently decode to buffers\nat 8, 12, 16, and 24 kHz so if for some reason the caller cannot use\ndata at the full sample rate, or knows the compressed data doesn't\nuse the full frequency range, it can request decoding at a reduced\nrate. Likewise, the decoder is capable of filling in either mono or\ninterleaved stereo pcm buffers, at the caller's request."]
  pub fn opus_decoder_create(
    Fs: opus_int32,
    channels: ::core::ffi::c_int,
    error: *mut ::core::ffi::c_int,
  ) -> *mut OpusDecoder;
  #[doc = "Initializes a previously allocated decoder state.\nThe state must be at least the size returned by opus_decoder_get_size().\nThis is intended for applications which use their own allocator instead of malloc. # See also\n\n> [`opus_decoder_create,opus_decoder_get_size`]\nTo reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusDecoder*</tt>: Decoder state.\n* `Fs` [in]  - <tt>opus_int32</tt>: Sampling rate to decode to (Hz).\nThis must be one of 8000, 12000, 16000,\n24000, or 48000.\n* `channels` [in]  - <tt>int</tt>: Number of channels (1 or 2) to decode\n@retval #OPUS_OK Success or [`opus_errorcodes`]"]
  pub fn opus_decoder_init(st: *mut OpusDecoder, Fs: opus_int32, channels: ::core::ffi::c_int) -> ::core::ffi::c_int;
  #[doc = "Decode an Opus packet.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusDecoder*</tt>: Decoder state\n* `data` [in]  - <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n* `len` [in]  - <tt>opus_int32</tt>: Number of bytes in payload*\n* `pcm` [out]  - <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length\nis frame_size*channels*sizeof(opus_int16)\n* `frame_size` [in]  - Number of samples per channel of available space in _pcm._\nIf this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\nnot be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\nthen frame_size needs to be exactly the duration of audio that is missing, otherwise the\ndecoder will not be in the optimal state to decode the next incoming packet. For the PLC and\nFEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n* `decode_fec` [in]  - <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\ndecoded. If no such data is available, the frame is decoded as if it were lost.\n\n# Returns\n\nNumber of decoded samples or [`opus_errorcodes`]"]
  pub fn opus_decode(
    st: *mut OpusDecoder,
    data: *const ::core::ffi::c_uchar,
    len: opus_int32,
    pcm: *mut opus_int16,
    frame_size: ::core::ffi::c_int,
    decode_fec: ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Decode an Opus packet.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusDecoder*</tt>: Decoder state\n* `data` [in]  - <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n* `len` [in]  - <tt>opus_int32</tt>: Number of bytes in payload*\n* `pcm` [out]  - <tt>opus_int32*</tt>: Output signal (interleaved if 2 channels) representing (or slightly exceeding) 24-bit values. length\nis frame_size*channels*sizeof(opus_int32)\n* `frame_size` [in]  - Number of samples per channel of available space in _pcm._\nIf this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\nnot be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\nthen frame_size needs to be exactly the duration of audio that is missing, otherwise the\ndecoder will not be in the optimal state to decode the next incoming packet. For the PLC and\nFEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n* `decode_fec` [in]  - <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\ndecoded. If no such data is available, the frame is decoded as if it were lost.\n\n# Returns\n\nNumber of decoded samples or [`opus_errorcodes`]"]
  pub fn opus_decode24(
    st: *mut OpusDecoder,
    data: *const ::core::ffi::c_uchar,
    len: opus_int32,
    pcm: *mut opus_int32,
    frame_size: ::core::ffi::c_int,
    decode_fec: ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Decode an Opus packet with floating point output.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusDecoder*</tt>: Decoder state\n* `data` [in]  - <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n* `len` [in]  - <tt>opus_int32</tt>: Number of bytes in payload\n* `pcm` [out]  - <tt>float*</tt>: Output signal (interleaved if 2 channels). length\nis frame_size*channels*sizeof(float)\n* `frame_size` [in]  - Number of samples per channel of available space in _pcm._\nIf this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\nnot be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\nthen frame_size needs to be exactly the duration of audio that is missing, otherwise the\ndecoder will not be in the optimal state to decode the next incoming packet. For the PLC and\nFEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n* `decode_fec` [in]  - <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\ndecoded. If no such data is available the frame is decoded as if it were lost.\n\n# Returns\n\nNumber of decoded samples or [`opus_errorcodes`]"]
  pub fn opus_decode_float(
    st: *mut OpusDecoder,
    data: *const ::core::ffi::c_uchar,
    len: opus_int32,
    pcm: *mut f32,
    frame_size: ::core::ffi::c_int,
    decode_fec: ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Perform a CTL function on an Opus decoder.\nGenerally the request and subsequent arguments are generated\nby a convenience macro.\n\n# Arguments\n\n* `st` - <tt>OpusDecoder*</tt>: Decoder state.\n* `request` - This and all remaining parameters should be replaced by one\nof the convenience macros in [`opus_genericctls`] or\n[`opus_decoderctls.`]\n\n# See also\n\n> [`opus_genericctls`]\n> [`opus_decoderctls`]"]
  pub fn opus_decoder_ctl(st: *mut OpusDecoder, request: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
  #[doc = "Frees an <code>OpusDecoder</code> allocated by opus_decoder_create().\n\n# Arguments\n\n* `st` [in]  - <tt>OpusDecoder*</tt>: State to be freed."]
  pub fn opus_decoder_destroy(st: *mut OpusDecoder);
  #[doc = "Gets the size of an <code>OpusDREDDecoder</code> structure.\n\n# Returns\n\nThe size in bytes."]
  pub fn opus_dred_decoder_get_size() -> ::core::ffi::c_int;
  #[doc = "Allocates and initializes an OpusDREDDecoder state.\n\n# Arguments\n\n* `error` [out]  - <tt>int*</tt>: #OPUS_OK Success or [`opus_errorcodes`]"]
  pub fn opus_dred_decoder_create(error: *mut ::core::ffi::c_int) -> *mut OpusDREDDecoder;
  #[doc = "Initializes an <code>OpusDREDDecoder</code> state.\n\n# Arguments\n\n* `dec` [in]  - <tt>OpusDREDDecoder*</tt>: State to be initialized."]
  pub fn opus_dred_decoder_init(dec: *mut OpusDREDDecoder) -> ::core::ffi::c_int;
  #[doc = "Frees an <code>OpusDREDDecoder</code> allocated by opus_dred_decoder_create().\n\n# Arguments\n\n* `dec` [in]  - <tt>OpusDREDDecoder*</tt>: State to be freed."]
  pub fn opus_dred_decoder_destroy(dec: *mut OpusDREDDecoder);
  #[doc = "Perform a CTL function on an Opus DRED decoder.\nGenerally the request and subsequent arguments are generated\nby a convenience macro.\n\n# Arguments\n\n* `dred_dec` - <tt>OpusDREDDecoder*</tt>: DRED Decoder state.\n* `request` - This and all remaining parameters should be replaced by one\nof the convenience macros in [`opus_genericctls`] or\n[`opus_decoderctls.`]\n\n# See also\n\n> [`opus_genericctls`]\n> [`opus_decoderctls`]"]
  pub fn opus_dred_decoder_ctl(dred_dec: *mut OpusDREDDecoder, request: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
  #[doc = "Gets the size of an <code>OpusDRED</code> structure.\n\n# Returns\n\nThe size in bytes."]
  pub fn opus_dred_get_size() -> ::core::ffi::c_int;
  #[doc = "Allocates and initializes a DRED state.\n\n# Arguments\n\n* `error` [out]  - <tt>int*</tt>: #OPUS_OK Success or [`opus_errorcodes`]"]
  pub fn opus_dred_alloc(error: *mut ::core::ffi::c_int) -> *mut OpusDRED;
  #[doc = "Frees an <code>OpusDRED</code> allocated by opus_dred_create().\n\n# Arguments\n\n* `dec` [in]  - <tt>OpusDRED*</tt>: State to be freed."]
  pub fn opus_dred_free(dec: *mut OpusDRED);
  #[doc = "Decode an Opus DRED packet.\n\n# Arguments\n\n* `dred_dec` [in]  - <tt>OpusDRED*</tt>: DRED Decoder state\n* `dred` [in]  - <tt>OpusDRED*</tt>: DRED state\n* `data` [in]  - <tt>char*</tt>: Input payload\n* `len` [in]  - <tt>opus_int32</tt>: Number of bytes in payload\n* `max_dred_samples` [in]  - <tt>opus_int32</tt>: Maximum number of DRED samples that may be needed (if available in the packet).\n* `sampling_rate` [in]  - <tt>opus_int32</tt>: Sampling rate used for max_dred_samples argument. Needs not match the actual sampling rate of the decoder.\n* `dred_end` [out]  - <tt>opus_int32*</tt>: Number of non-encoded (silence) samples between the DRED timestamp and the last DRED sample.\n* `defer_processing` [in]  - <tt>int</tt>: Flag (0 or 1). If set to one, the CPU-intensive part of the DRED decoding is deferred until opus_dred_process() is called.\n\n# Returns\n\nOffset (positive) of the first decoded DRED samples, zero if no DRED is present, or [`opus_errorcodes`]"]
  pub fn opus_dred_parse(
    dred_dec: *mut OpusDREDDecoder,
    dred: *mut OpusDRED,
    data: *const ::core::ffi::c_uchar,
    len: opus_int32,
    max_dred_samples: opus_int32,
    sampling_rate: opus_int32,
    dred_end: *mut ::core::ffi::c_int,
    defer_processing: ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Finish decoding an Opus DRED packet. The function only needs to be called if opus_dred_parse() was called with defer_processing=1.\nThe source and destination will often be the same DRED state.\n\n# Arguments\n\n* `dred_dec` [in]  - <tt>OpusDRED*</tt>: DRED Decoder state\n* `src` [in]  - <tt>OpusDRED*</tt>: Source DRED state to start the processing from.\n* `dst` [out]  - <tt>OpusDRED*</tt>: Destination DRED state to store the updated state after processing.\n\n# Returns\n\n[`opus_errorcodes`]"]
  pub fn opus_dred_process(
    dred_dec: *mut OpusDREDDecoder,
    src: *const OpusDRED,
    dst: *mut OpusDRED,
  ) -> ::core::ffi::c_int;
  #[doc = "Decode audio from an Opus DRED packet with 16-bit output.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusDecoder*</tt>: Decoder state\n* `dred` [in]  - <tt>OpusDRED*</tt>: DRED state\n* `dred_offset` [in]  - <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).\n* `pcm` [out]  - <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length\nis frame_size*channels*sizeof(opus_int16)\n* `frame_size` [in]  - Number of samples per channel to decode in _pcm._\nframe_size <b>must</b> be a multiple of 2.5 ms.\n\n# Returns\n\nNumber of decoded samples or [`opus_errorcodes`]"]
  pub fn opus_decoder_dred_decode(
    st: *mut OpusDecoder,
    dred: *const OpusDRED,
    dred_offset: opus_int32,
    pcm: *mut opus_int16,
    frame_size: opus_int32,
  ) -> ::core::ffi::c_int;
  #[doc = "Decode audio from an Opus DRED packet with 24-bit output.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusDecoder*</tt>: Decoder state\n* `dred` [in]  - <tt>OpusDRED*</tt>: DRED state\n* `dred_offset` [in]  - <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).\n* `pcm` [out]  - <tt>opus_int32*</tt>: Output signal (interleaved if 2 channels). length\nis frame_size*channels*sizeof(opus_int16)\n* `frame_size` [in]  - Number of samples per channel to decode in _pcm._\nframe_size <b>must</b> be a multiple of 2.5 ms.\n\n# Returns\n\nNumber of decoded samples or [`opus_errorcodes`]"]
  pub fn opus_decoder_dred_decode24(
    st: *mut OpusDecoder,
    dred: *const OpusDRED,
    dred_offset: opus_int32,
    pcm: *mut opus_int32,
    frame_size: opus_int32,
  ) -> ::core::ffi::c_int;
  #[doc = "Decode audio from an Opus DRED packet with floating point output.\n\n# Arguments\n\n* `st` [in]  - <tt>OpusDecoder*</tt>: Decoder state\n* `dred` [in]  - <tt>OpusDRED*</tt>: DRED state\n* `dred_offset` [in]  - <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).\n* `pcm` [out]  - <tt>float*</tt>: Output signal (interleaved if 2 channels). length\nis frame_size*channels*sizeof(float)\n* `frame_size` [in]  - Number of samples per channel to decode in _pcm._\nframe_size <b>must</b> be a multiple of 2.5 ms.\n\n# Returns\n\nNumber of decoded samples or [`opus_errorcodes`]"]
  pub fn opus_decoder_dred_decode_float(
    st: *mut OpusDecoder,
    dred: *const OpusDRED,
    dred_offset: opus_int32,
    pcm: *mut f32,
    frame_size: opus_int32,
  ) -> ::core::ffi::c_int;
  #[doc = "Parse an opus packet into one or more frames.\nOpus_decode will perform this operation internally so most applications do\nnot need to use this function.\nThis function does not copy the frames, the returned pointers are pointers into\nthe input packet.\n\n# Arguments\n\n* `data` [in]  - <tt>char*</tt>: Opus packet to be parsed\n* `len` [in]  - <tt>opus_int32</tt>: size of data\n* `out_toc` [out]  - <tt>char*</tt>: TOC pointer\n* `frames` [out]  - <tt>char*[48]</tt> encapsulated frames\n* `size` [out]  - <tt>opus_int16[48]</tt> sizes of the encapsulated frames\n* `payload_offset` [out]  - <tt>int*</tt>: returns the position of the payload within the packet (in bytes)\n\n# Returns\n\nnumber of frames"]
  pub fn opus_packet_parse(
    data: *const ::core::ffi::c_uchar,
    len: opus_int32,
    out_toc: *mut ::core::ffi::c_uchar,
    frames: *mut *const ::core::ffi::c_uchar,
    size: *mut opus_int16,
    payload_offset: *mut ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Gets the bandwidth of an Opus packet.\n\n# Arguments\n\n* `data` [in]  - <tt>char*</tt>: Opus packet\n@retval OPUS_BANDWIDTH_NARROWBAND Narrowband (4kHz bandpass)\n@retval OPUS_BANDWIDTH_MEDIUMBAND Mediumband (6kHz bandpass)\n@retval OPUS_BANDWIDTH_WIDEBAND Wideband (8kHz bandpass)\n@retval OPUS_BANDWIDTH_SUPERWIDEBAND Superwideband (12kHz bandpass)\n@retval OPUS_BANDWIDTH_FULLBAND Fullband (20kHz bandpass)\n@retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
  pub fn opus_packet_get_bandwidth(data: *const ::core::ffi::c_uchar) -> ::core::ffi::c_int;
  #[doc = "Gets the number of samples per frame from an Opus packet.\n\n# Arguments\n\n* `data` [in]  - <tt>char*</tt>: Opus packet.\nThis must contain at least one byte of\ndata.\n* `Fs` [in]  - <tt>opus_int32</tt>: Sampling rate in Hz.\nThis must be a multiple of 400, or\ninaccurate results will be returned.\n\n# Returns\n\nNumber of samples per frame."]
  pub fn opus_packet_get_samples_per_frame(data: *const ::core::ffi::c_uchar, Fs: opus_int32) -> ::core::ffi::c_int;
  #[doc = "Gets the number of channels from an Opus packet.\n\n# Arguments\n\n* `data` [in]  - <tt>char*</tt>: Opus packet\n\n# Returns\n\nNumber of channels\n@retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
  pub fn opus_packet_get_nb_channels(data: *const ::core::ffi::c_uchar) -> ::core::ffi::c_int;
  #[doc = "Gets the number of frames in an Opus packet.\n\n# Arguments\n\n* `packet` [in]  - <tt>char*</tt>: Opus packet\n* `len` [in]  - <tt>opus_int32</tt>: Length of packet\n\n# Returns\n\nNumber of frames\n@retval OPUS_BAD_ARG Insufficient data was passed to the function\n@retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
  pub fn opus_packet_get_nb_frames(packet: *const ::core::ffi::c_uchar, len: opus_int32) -> ::core::ffi::c_int;
  #[doc = "Gets the number of samples of an Opus packet.\n\n# Arguments\n\n* `packet` [in]  - <tt>char*</tt>: Opus packet\n* `len` [in]  - <tt>opus_int32</tt>: Length of packet\n* `Fs` [in]  - <tt>opus_int32</tt>: Sampling rate in Hz.\nThis must be a multiple of 400, or\ninaccurate results will be returned.\n\n# Returns\n\nNumber of samples\n@retval OPUS_BAD_ARG Insufficient data was passed to the function\n@retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
  pub fn opus_packet_get_nb_samples(
    packet: *const ::core::ffi::c_uchar,
    len: opus_int32,
    Fs: opus_int32,
  ) -> ::core::ffi::c_int;
  #[doc = "Checks whether an Opus packet has LBRR.\n\n# Arguments\n\n* `packet` [in]  - <tt>char*</tt>: Opus packet\n* `len` [in]  - <tt>opus_int32</tt>: Length of packet\n\n# Returns\n\n1 is LBRR is present, 0 otherwise\n@retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
  pub fn opus_packet_has_lbrr(packet: *const ::core::ffi::c_uchar, len: opus_int32) -> ::core::ffi::c_int;
  #[doc = "Gets the number of samples of an Opus packet.\n\n# Arguments\n\n* `dec` [in]  - <tt>OpusDecoder*</tt>: Decoder state\n* `packet` [in]  - <tt>char*</tt>: Opus packet\n* `len` [in]  - <tt>opus_int32</tt>: Length of packet\n\n# Returns\n\nNumber of samples\n@retval OPUS_BAD_ARG Insufficient data was passed to the function\n@retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
  pub fn opus_decoder_get_nb_samples(
    dec: *const OpusDecoder,
    packet: *const ::core::ffi::c_uchar,
    len: opus_int32,
  ) -> ::core::ffi::c_int;
  #[doc = "Applies soft-clipping to bring a float signal within the [-1,1] range. If\nthe signal is already in that range, nothing is done. If there are values\noutside of [-1,1], then the signal is clipped as smoothly as possible to\nboth fit in the range and avoid creating excessive distortion in the\nprocess.\n\n# Arguments\n\n* `pcm` [in,out]  - <tt>float*</tt>: Input PCM and modified PCM\n* `frame_size` [in]  - <tt>int</tt> Number of samples per channel to process\n* `channels` [in]  - <tt>int</tt>: Number of channels\n* `softclip_mem` [in,out]  - <tt>float*</tt>: State memory for the soft clipping process (one float per channel, initialized to zero)"]
  pub fn opus_pcm_soft_clip(
    pcm: *mut f32,
    frame_size: ::core::ffi::c_int,
    channels: ::core::ffi::c_int,
    softclip_mem: *mut f32,
  );
  #[doc = "Gets the size of an <code>OpusRepacketizer</code> structure.\n\n# Returns\n\nThe size in bytes."]
  pub fn opus_repacketizer_get_size() -> ::core::ffi::c_int;
  #[doc = "(Re)initializes a previously allocated repacketizer state.\nThe state must be at least the size returned by opus_repacketizer_get_size().\nThis can be used for applications which use their own allocator instead of\nmalloc().\nIt must also be called to reset the queue of packets waiting to be\nrepacketized, which is necessary if the maximum packet duration of 120 ms\nis reached or if you wish to submit packets with a different Opus\nconfiguration (coding mode, audio bandwidth, frame size, or channel count).\nFailure to do so will prevent a new packet from being added with\nopus_repacketizer_cat().\n\n# See also\n\n> [`opus_repacketizer_create`]\n> [`opus_repacketizer_get_size`]\n> [`opus_repacketizer_cat`]\n\n# Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state to\n(re)initialize.\n\n# Returns\n\nA pointer to the same repacketizer state that was passed in."]
  pub fn opus_repacketizer_init(rp: *mut OpusRepacketizer) -> *mut OpusRepacketizer;
  #[doc = "Allocates memory and initializes the new repacketizer with\nopus_repacketizer_init()."]
  pub fn opus_repacketizer_create() -> *mut OpusRepacketizer;
  #[doc = "Frees an <code>OpusRepacketizer</code> allocated by\nopus_repacketizer_create().\n\n# Arguments\n\n* `rp` [in]  - <tt>OpusRepacketizer*</tt>: State to be freed."]
  pub fn opus_repacketizer_destroy(rp: *mut OpusRepacketizer);
  #[doc = "Add a packet to the current repacketizer state.\nThis packet must match the configuration of any packets already submitted\nfor repacketization since the last call to opus_repacketizer_init().\nThis means that it must have the same coding mode, audio bandwidth, frame\nsize, and channel count.\nThis can be checked in advance by examining the top 6 bits of the first\nbyte of the packet, and ensuring they match the top 6 bits of the first\nbyte of any previously submitted packet.\nThe total duration of audio in the repacketizer state also must not exceed\n120 ms, the maximum duration of a single packet, after adding this packet.\nThe contents of the current repacketizer state can be extracted into new\npackets using opus_repacketizer_out() or opus_repacketizer_out_range().\nIn order to add a packet with a different configuration or to add more\naudio beyond 120 ms, you must clear the repacketizer state by calling\nopus_repacketizer_init().\nIf a packet is too large to add to the current repacketizer state, no part\nof it is added, even if it contains multiple frames, some of which might\nfit.\nIf you wish to be able to add parts of such packets, you should first use\nanother repacketizer to split the packet into pieces and add them\nindividually.\n\n# See also\n\n> [`opus_repacketizer_out_range`]\n> [`opus_repacketizer_out`]\n> [`opus_repacketizer_init`]\n\n# Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state to which to\nadd the packet.\n* `data` [in]  - <tt>const unsigned char*</tt>: The packet data.\nThe application must ensure\nthis pointer remains valid\nuntil the next call to\nopus_repacketizer_init() or\nopus_repacketizer_destroy().\n* `len` - <tt>opus_int32</tt>: The number of bytes in the packet data.\n\n# Returns\n\nAn error code indicating whether or not the operation succeeded.\n@retval #OPUS_OK The packet's contents have been added to the repacketizer\nstate.\n@retval #OPUS_INVALID_PACKET The packet did not have a valid TOC sequence,\nthe packet's TOC sequence was not compatible\nwith previously submitted packets (because\nthe coding mode, audio bandwidth, frame size,\nor channel count did not match), or adding\nthis packet would increase the total amount of\naudio stored in the repacketizer state to more\nthan 120 ms."]
  pub fn opus_repacketizer_cat(
    rp: *mut OpusRepacketizer,
    data: *const ::core::ffi::c_uchar,
    len: opus_int32,
  ) -> ::core::ffi::c_int;
  #[doc = "Construct a new packet from data previously submitted to the repacketizer\nstate via opus_repacketizer_cat().\n\n# Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state from which to\nconstruct the new packet.\n* `begin` - <tt>int</tt>: The index of the first frame in the current\nrepacketizer state to include in the output.\n* `end` - <tt>int</tt>: One past the index of the last frame in the\ncurrent repacketizer state to include in the\noutput.\n* `data` [out]  - <tt>const unsigned char*</tt>: The buffer in which to\nstore the output packet.\n* `maxlen` - <tt>opus_int32</tt>: The maximum number of bytes to store in\nthe output buffer. In order to guarantee\nsuccess, this should be at least\n<code>1276</code> for a single frame,\nor for multiple frames,\n<code>1277*(end-begin)</code>.\nHowever, <code>1*(end-begin)</code> plus\nthe size of all packet data submitted to\nthe repacketizer since the last call to\nopus_repacketizer_init() or\nopus_repacketizer_create() is also\nsufficient, and possibly much smaller.\n\n# Returns\n\nThe total size of the output packet on success, or an error code\non failure.\n@retval #OPUS_BAD_ARG <code>[begin,end)</code> was an invalid range of\nframes (begin < 0, begin >= end, or end >\nopus_repacketizer_get_nb_frames()).\n@retval #OPUS_BUFFER_TOO_SMALL _maxlen_ was insufficient to contain the\ncomplete output packet."]
  pub fn opus_repacketizer_out_range(
    rp: *mut OpusRepacketizer,
    begin: ::core::ffi::c_int,
    end: ::core::ffi::c_int,
    data: *mut ::core::ffi::c_uchar,
    maxlen: opus_int32,
  ) -> opus_int32;
  #[doc = "Return the total number of frames contained in packet data submitted to\nthe repacketizer state so far via opus_repacketizer_cat() since the last\ncall to opus_repacketizer_init() or opus_repacketizer_create().\nThis defines the valid range of packets that can be extracted with\nopus_repacketizer_out_range() or opus_repacketizer_out().\n\n# Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state containing the\nframes.\n\n# Returns\n\nThe total number of frames contained in the packet data submitted\nto the repacketizer state."]
  pub fn opus_repacketizer_get_nb_frames(rp: *mut OpusRepacketizer) -> ::core::ffi::c_int;
  #[doc = "Construct a new packet from data previously submitted to the repacketizer\nstate via opus_repacketizer_cat().\nThis is a convenience routine that returns all the data submitted so far\nin a single packet.\nIt is equivalent to calling\n@code opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),\ndata, maxlen)\n@endcode # Arguments\n\n* `rp` - <tt>OpusRepacketizer*</tt>: The repacketizer state from which to\nconstruct the new packet.\n* `data` [out]  - <tt>const unsigned char*</tt>: The buffer in which to\nstore the output packet.\n* `maxlen` - <tt>opus_int32</tt>: The maximum number of bytes to store in\nthe output buffer. In order to guarantee\nsuccess, this should be at least\n<code>1277*opus_repacketizer_get_nb_frames(rp)</code>.\nHowever,\n<code>1*opus_repacketizer_get_nb_frames(rp)</code>\nplus the size of all packet data\nsubmitted to the repacketizer since the\nlast call to opus_repacketizer_init() or\nopus_repacketizer_create() is also\nsufficient, and possibly much smaller.\n\n# Returns\n\nThe total size of the output packet on success, or an error code\non failure.\n@retval #OPUS_BUFFER_TOO_SMALL _maxlen_ was insufficient to contain the\ncomplete output packet."]
  pub fn opus_repacketizer_out(
    rp: *mut OpusRepacketizer,
    data: *mut ::core::ffi::c_uchar,
    maxlen: opus_int32,
  ) -> opus_int32;
  #[doc = "Pads a given Opus packet to a larger size (possibly changing the TOC sequence).\n\n# Arguments\n\n* `data` [in,out]  - <tt>const unsigned char*</tt>: The buffer containing the\npacket to pad.\n* `len` - <tt>opus_int32</tt>: The size of the packet.\nThis must be at least 1.\n* `new_len` - <tt>opus_int32</tt>: The desired size of the packet after padding.\nThis must be at least as large as len.\n\n# Returns\n\nan error code\n@retval #OPUS_OK _on_ success.\n@retval #OPUS_BAD_ARG _len_ was less than 1 or new_len was less than len.\n@retval #OPUS_INVALID_PACKET _data_ did not contain a valid Opus packet."]
  pub fn opus_packet_pad(data: *mut ::core::ffi::c_uchar, len: opus_int32, new_len: opus_int32) -> ::core::ffi::c_int;
  #[doc = "Remove all padding from a given Opus packet and rewrite the TOC sequence to\nminimize space usage.\n\n# Arguments\n\n* `data` [in,out]  - <tt>const unsigned char*</tt>: The buffer containing the\npacket to strip.\n* `len` - <tt>opus_int32</tt>: The size of the packet.\nThis must be at least 1.\n\n# Returns\n\nThe new size of the output packet on success, or an error code\non failure.\n@retval #OPUS_BAD_ARG _len_ was less than 1.\n@retval #OPUS_INVALID_PACKET _data_ did not contain a valid Opus packet."]
  pub fn opus_packet_unpad(data: *mut ::core::ffi::c_uchar, len: opus_int32) -> opus_int32;
  #[doc = "Pads a given Opus multi-stream packet to a larger size (possibly changing the TOC sequence).\n\n# Arguments\n\n* `data` [in,out]  - <tt>const unsigned char*</tt>: The buffer containing the\npacket to pad.\n* `len` - <tt>opus_int32</tt>: The size of the packet.\nThis must be at least 1.\n* `new_len` - <tt>opus_int32</tt>: The desired size of the packet after padding.\nThis must be at least 1.\n* `nb_streams` - <tt>opus_int32</tt>: The number of streams (not channels) in the packet.\nThis must be at least as large as len.\n\n# Returns\n\nan error code\n@retval #OPUS_OK _on_ success.\n@retval #OPUS_BAD_ARG _len_ was less than 1.\n@retval #OPUS_INVALID_PACKET _data_ did not contain a valid Opus packet."]
  pub fn opus_multistream_packet_pad(
    data: *mut ::core::ffi::c_uchar,
    len: opus_int32,
    new_len: opus_int32,
    nb_streams: ::core::ffi::c_int,
  ) -> ::core::ffi::c_int;
  #[doc = "Remove all padding from a given Opus multi-stream packet and rewrite the TOC sequence to\nminimize space usage.\n\n# Arguments\n\n* `data` [in,out]  - <tt>const unsigned char*</tt>: The buffer containing the\npacket to strip.\n* `len` - <tt>opus_int32</tt>: The size of the packet.\nThis must be at least 1.\n* `nb_streams` - <tt>opus_int32</tt>: The number of streams (not channels) in the packet.\nThis must be at least 1.\n\n# Returns\n\nThe new size of the output packet on success, or an error code\non failure.\n@retval #OPUS_BAD_ARG _len_ was less than 1 or new_len was less than len.\n@retval #OPUS_INVALID_PACKET _data_ did not contain a valid Opus packet."]
  pub fn opus_multistream_packet_unpad(
    data: *mut ::core::ffi::c_uchar,
    len: opus_int32,
    nb_streams: ::core::ffi::c_int,
  ) -> opus_int32;
}
